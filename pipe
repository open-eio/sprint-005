#!/usr/bin/env python

import sys, os, argparse, glob, json, urllib2
from collections import OrderedDict

LOGFILE     = sys.stderr
IN_STREAM   = sys.stdin

# in a future revision, replace all calls to 'sys.stdout' below with OUT_STREAM
#OUT_STREAM  = sys.stdout

pipepath="./pipefile"

# parse the command line arguments
parser = argparse.ArgumentParser()

# need to revise to make 'write' and 'read' mutually exclusive options ...
parser.add_argument("-w","--write", help="write to pipe file")
parser.add_argument("-r","--read", help="read from pipe file")

# verbose
parser.add_argument("-v", "--verbose", action="store_true", help="increase output verbosity")

args = parser.parse_args()

# process the input
try:
    if(args.write):
        try: 
            #should check to see if there's already a pipefile
            pipepath=args.write
            os.mkfifo(pipepath)
        except OSError:
            pass
        wp = open(pipepath,'w')
        
        for line in IN_STREAM:
            wp.write(line)
        wp.close()

    if(args.read):
        pipepath=args.read
        rp=open(pipepath,'r')
        response=rp.read()
        splitResponse=response.split("\n")
        sys.stdout.write('{')
        index=0
        iMax=len(splitResponse)
        i=0
        while (i<(iMax-1)):
            #print index
            index=index+1
            sys.stdout.write(splitResponse[i])
            if (i<(iMax-2)):
                sys.stdout.write(",")
            i=i+1
        sys.stdout.write("}")
        rp.close()

except Exception, exc:
    LOGFILE.write("ERROR: %s" % exc)
finally:
    LOGFILE.close()
    IN_STREAM.close()
